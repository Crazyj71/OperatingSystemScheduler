head	1.4;
access;
symbols;
locks
	o1-wyatt:1.4; strict;
comment	@ * @;


1.4
date	2018.03.21.20.04.29;	author o1-wyatt;	state Exp;
branches;
next	1.3;

1.3
date	2018.03.19.20.19.00;	author o1-wyatt;	state Exp;
branches;
next	1.2;

1.2
date	2018.03.10.23.16.58;	author o1-wyatt;	state Exp;
branches;
next	1.1;

1.1
date	2018.03.10.23.10.57;	author o1-wyatt;	state Exp;
branches;
next	;


desc
@OSS created
/
@


1.4
log
@Update
@
text
@//MASTER PROGRAM
#define _GNU_SOURCE
#define _SVID_SOURCE
#define _POSIX_SOURCE
#include <string.h>
#include <errno.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <time.h>
#include <sys/msg.h>
#include "sharedmemory.h"

//GLOBALS
int pid;
int run;
int shm_id;
int msqid;
int i = -1;

//KILL CHILDREN
void kill_child(int sig)
{
    printf("SIMULATION TIME OUT\n %d Processes Ran\n", i);
    while(1)
    {
        int childpid=wait(NULL);
        if(childpid==-1) break;
    }

    if(pid!=getpid())
        kill(getpid(),SIGINT);

    msgctl(msqid, IPC_RMID, NULL);          //FREE SHARED MESSAGE QUEUE
    shmctl(shm_id, IPC_RMID, NULL);         //FREE SHARED MEMORY DATA

    exit(0);
}

void HANDLER(int sig)
{
    while(1)
    {
        int childpid=wait(NULL);
        if(childpid==-1) break;
    }
    msgctl(msqid, IPC_RMID, NULL);          //FREE SHARED MESSAGE QUEUE
    shmctl(shm_id, IPC_RMID, NULL);         //FREE SHARED MEMORY DATA
    exit(0);
}

//LOG FILE PRINT FUNCTIONS//////////////////////////////////////////////////////
char filename[20];
void writeLogNewProcess(FILE *fp, int PID, int QUEUE, int sec, int nano)
{
    fp=fopen(filename,"a");
    fprintf(fp, "CREATE: Generating process with PID %d and putting it in queue %d at time %d:%d\n", PID, QUEUE, sec, nano);
    fclose(fp);
}/////////////////////////////////////////////////////////////////////////////////////////////////////

void writeLogRunProcess(FILE *fp, int PID, int QUEUE, int sec, int nano, int dispatch)
{
    fp=fopen(filename,"a");
    fprintf(fp, "RUN:    Dispatching process with PID %d from queue %d at time %d:%d, this dispatch was %d nanoseconds\n", PID,
            QUEUE,sec,nano,dispatch);
    fclose(fp);
}/////////////////////////////////////////////////////////////////////////////////////////////////////

void writeLogQueue(FILE *fp, int PID, int QUEUE)
{
    fp=fopen(filename,"a");
    fprintf(fp, "QUEUE:  Putting Process %d into Queue %d", PID, QUEUE);
    if(QUEUE==4)fprintf(fp, "(BLOCKED)");
    fprintf(fp, "\n");
    fclose(fp);
}/////////////////////////////////////////////////////////////////////////////////////////////////////

void writeLogEnd(FILE *fp, int PID, int sec, int nanosec)
{
    fp=fopen(filename,"a");
    fprintf(fp, "END:    Process %d ended after running for %d:%d\n", PID, sec, nanosec);
    fclose(fp);
}/////////////////////////////////////////////////////////////////////////////////////////////////////

void writeLogUnblock(FILE *fp, int PID)
{
    fp=fopen(filename,"a");
    fprintf(fp, "UNBLK:  Process %d removed from the blocked queue(UNBLOCKED)\n",PID);
    fclose(fp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////MAIN//////////////////////////////////////////
int main(int argc, char *argv[])
{
//SET GLOBALS
    run=0;
    pid=getpid();

//SET UP SIGNAL HANDLING
    signal(SIGALRM,(void (*)(int))kill_child);
    signal(SIGINT, HANDLER);
    while(run==0)
    {

//INITIALIZE VARS
        char opt;
        int s;
        int z;
        pid_t childpid;

//GET OPTION IS SET
        while ( (opt= getopt(argc,argv, "dhs:l:t:")) !=-1 )
        {
            switch ( opt)
            {
            case 'h':
                printf("-s [slave#]\n -l [logfile]\n -t [time]\n -d FOR DEFAULTS");
                return 0;
            case 'l':
                memcpy(filename, optarg, 20);
                break;
            case 's':
                s = atoi(optarg);
                break;
            case 't':
                z = atoi(optarg);
                break;
            case 'd':
                s = 1;
                z=20;
                memcpy(filename, "file.log", 10);
                break;
            }
        }

//CHECK FOR VALID NUMBER OF COMMAND ARGS & VALID N
        if (argc == 1 )
        {
            fprintf(stderr, "See ./oss -h for help\n");
            return 1;
        }


//INITIALIZE BIT-ARRAY
        int processOpen[20];
        int pidArray[20];
        for(int j=0; j<20; j++)
        {
            processOpen[j] = 0;
            pidArray[20]=0;
        }






//INITIALIZE TIME BETWEEN PROCESSES
        int maxTimeBetweenNewProcs = 1000000000;

//INITIALIZE REALTIME PROCESS FRACTION
        float realtime= .2;

//INITIALIZE QUEUES
        node_t *priority0 = NULL;
        node_t *priority1 = NULL;
        node_t *priority2 = NULL;
        node_t *priority3 = NULL;
        node_t *BlockQueue= NULL;

//SET AN ALARM IF PROGRAM TAKES TOO LONG
        alarm(z);

//SHOW USER WHAT ARGS WE RECEIVED
        printf("Running with S:%d T:%d L:%s\n", s, z, filename);

//INITIALIZE DATA VARS
        key_t     mem_key;
        struct sharedMemoryStruct *shm_ptr;

//GENERATE KEY
        mem_key = ftok("a", 1);
        shm_id = shmget(mem_key, MEMORYSIZE, IPC_CREAT |
                        0666);
        if (shm_id < 0)
        {
            perror("shmget");
            exit(1);
        }

//ATTACH OR CREATE DATA STRUCT
        shm_ptr = (struct sharedMemoryStruct *) shmat(shm_id, NULL, 0);
        /*
        attach */
        if ((long) shm_ptr == -1)
        {
            perror("shmat");
            exit(1);
        }

//Initialize DATA
        shm_ptr->systemTime.seconds=0;
        shm_ptr->systemTime.nanoseconds=0;
	
	for(int j=0; j<100000; j++){
	shm_ptr->blocktime[j] = 0;
        shm_ptr->runtime[j] = 0;
        shm_ptr->waittime[j] = 0;
	}
//DATA STRUCT SUCCESS
        printf("data struct made\n");

//INITIALIZE MESSAGE QUEUE
        key_t key; /* key to be passed to msgget() */
//int msgflg; /* msgflg to be passed to msgget() */

//INITIALIZE PROCESS MESSAGE QUEUES
        mymsg_t *message[40];
        for(int j=0; j<40; j++)
        {
            message[j] = (mymsg_t *) malloc(sizeof(mymsg_t));
            message[j]->mtype=j+1;
            memcpy(message[j]->mtext, "", 100);
        }

        key=ftok("/b",1);					//GENERATE KEY
        msqid = msgget(key, (IPC_CREAT | 0666));
        msgctl(msqid, IPC_RMID, NULL);
        msqid = msgget(key, (IPC_CREAT | 0666));		//IF MSQID EXISTS, REMOVE IT AND WRITE OVER

//MESSAGE SET UP SUCCESS
        printf("message queue 1 made\n");

//CREATE OR OVERWRITE A LOGFILE
        FILE * logfile;
        logfile=fopen(filename,"w");
        fclose(logfile);



//MAKE CHILDREN
        printf("creating children\n");
        int limit=20;
        //INITIALIZE DATA FOR LOOP CONTROL
        int count=0;
        int kval=0;
        int newProcessTimer;
        while(run==0 && i < 100)
        {
            newProcessTimer = rand()%(maxTimeBetweenNewProcs/2)+1;//TIME BETWEEN NEW PROCESSES
            if(count==limit) 	//ONLY ALLOW MAX LIMIT OF PROCESSES AT A TIME
            {
                printf("waiting\n");
                int id = wait(NULL);	//WAIT WHILE AT MAX LIMIT
                for(int j=0; j<20; j++)
                {
                    if(id==pidArray[j]) processOpen[j] = 0;//FREE BIT ARRAY IF WAITED FOR A CHILD
                }
                count--;
            }

            //INCREMENT LOOP CONTROL
            printf("PROCESS COUNT: %d\n", count);

            for(int k = 0; k<20; k++)//LOOP THROUGH PROCESS BLOCK
            {
                //CHECK IF NANOSECONDS CAN BECOME A SECOND
                if(shm_ptr->processBlock[k].timeInSystem.nanoseconds>1000000000)
                {
                    shm_ptr->processBlock[k].timeInSystem.seconds++;
                    shm_ptr->processBlock[k].timeInSystem.nanoseconds-=1000000000;
                }

                fflush(stdout);
                printf("Checking slot %d\n", k);

                if(processOpen[k]==0) 		//CHECK FOR A FREE SLOT
                {
                    printf("Slot %d filled\n", k);
                    processOpen[k]=1;    //FILL THE SLOT
                    shm_ptr->processBlock[k].processID=k;
                    srand(time(NULL)*k);
                    int randprior = rand()%100 + 1; //CREATE A RANDOM NUMBER FOR PRIORITY
                    int queuenum;//FOR LOGFILE
                    if(randprior<(100*realtime))
                    {
                        queuenum=0;
                        shm_ptr->processBlock[k].priority=0;
                        enqueue(&priority0,k);
                        writeLogQueue(logfile, k, 0);               //PUT INTO REALTIME PROCESS QUEUE
                        shm_ptr->processBlock[k].firstrun = 1;
                        printf("%d sent to Priority 0\n",k);
                    }
                    else
                    {
                        queuenum=1;
                        shm_ptr->processBlock[k].priority=1;
                        enqueue(&priority1,k);
                        writeLogQueue(logfile, k, 1);               //PUT INTO QUEUE 1
                        shm_ptr->processBlock[k].firstrun = 1;
                        printf("%d sent to Priority 1\n",k);
                    }

                    srand(time(NULL));
                    int runtime = rand()%(maxTimeBetweenNewProcs) +1; //CREATE A RANDOM RUNTIME
                    shm_ptr->processBlock[k].timeLeft=runtime;
                    shm_ptr->processBlock[k].timeUsedLast=0;
                    shm_ptr->processBlock[k].timeInSystem.seconds=0; //SET AND CLEAR DATA VALUES
                    shm_ptr->processBlock[k].timeInSystem.nanoseconds=0;
                    printf("%d will run for %d\n", k,runtime);
                    count++;
                    i++;
                    kval=k;//FOR USER PROCESS TO KNOW ITS OWN PID
                    writeLogNewProcess(logfile, k, queuenum, shm_ptr->systemTime.seconds, shm_ptr->systemTime.nanoseconds);
                    childpid = fork();		//CREATE CHILD
                    pidArray[k]=childpid;
                    break;

                }

            }

            if(childpid==0) break;
            if(childpid<0)
            {
                perror("childpid");	//HANDLE FORK ERROR
                exit(1);
            }
            int processRan=1;

            //MAIN DRIVER FOR THE OPERATING SYSTEM WHILE LOOP

            while(count<21 && childpid>0 && processRan==1)
            {
                processRan =0;
                if(shm_ptr->systemTime.nanoseconds>1000000000) //SEE IF NANOSECONDS CAN BECOME SECONDS
                {
                    shm_ptr->systemTime.seconds++;
                    shm_ptr->systemTime.nanoseconds-=1000000000;
                }

/////////////////////////////////////////////////////////////////////////////////////////////////////ROUND ROBIN QUEUE 0
                int pran=0;
                int val = dequeue(&priority0);
                while(val>-1)
                {
                    print_list(priority0);
                    pran=1;
                    fflush(stdout);
                    printf("DEQUEUE: %d\n", val);
                    message[val]->timeToRun = 1000000; //one millisecond
                    message[val]->running=1;
                    msgsnd(msqid, message[val], MSG, 0);
                    int dispatch = rand()%10000+100;
                    shm_ptr->systemTime.nanoseconds += dispatch;
                    writeLogRunProcess(logfile, val, 0, shm_ptr->systemTime.seconds, shm_ptr->systemTime.nanoseconds, dispatch);
                    msgrcv(msqid, message[val+20], MSG, val+21,0);
                    if(shm_ptr->processBlock[val].timeLeft < 0 || message[val+20]->running==0)//IF PROCESS RUNS OUT OF TIME OR ENDS ITSELF
                    {
                        shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=shm_ptr->processBlock[val].timeLeft;
                        printf("%d Ran out of time\n", val);
                        message[val]->running=0;
                        if(message[val+20]->running==1)//IF IT RAN OUT OF TIME, SEND THE KILL MESSAGE
                        {
                            msgsnd(msqid, message[val], MSG, 0);
                            msgrcv(msqid, message[val+20], MSG, val+21, 0);
                        }
                        processOpen[val]=0;
                        writeLogEnd(logfile, val, shm_ptr->processBlock[val].timeInSystem.seconds,shm_ptr->processBlock[val].timeInSystem.nanoseconds);
                    }
                    else //ELSE THE PROCESS HAS NOT RAN OUT OF TIME
                    {
                        enqueue(&priority0,val); //PUT BACK INTO THE QUEUE

                        writeLogQueue(logfile, val, 0);
                        newProcessTimer-=message[val+20]->timeToRun;
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft -= message[val+20]->timeToRun;
                        printf("%d has %d time left\n", val, shm_ptr->processBlock[val].timeLeft);
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                    }
                    if(newProcessTimer<0) break; //IF ITS TIME FOR A NEW PROCESS, BREAK OUT QUEUE 0

                    val=dequeue(&priority0);
                }
                processRan=pran;
                if(newProcessTimer<0) break; //BREAK OUT OF DRIVER IF TIME FOR A NEW PROCESS
///////////////////////////////////////////////////////////////////////////////////////////////////// QUEUE 1 START

                val = dequeue(&BlockQueue); //SEE IF SOMETHING IS IN BLOCKED QUEUE
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                {//IF SOMETHING IS IN BLOCKED, BUT ITS TIME IS NOT READY YET, PUT IT BACK IN
                    enqueue(&BlockQueue, val);
                    val = dequeue(&priority1);
                }
                else if(val==-1) val = dequeue(&priority1); //IF NOTHING IS IN BLOCKED QUEUE, DEQUEUE FROM QUEUE 1
                else writeLogUnblock(logfile, val);

                while(val>-1)
                {
                    pran=1;
                    fflush(stdout);
                    printf("DEQUEUE: %d\n", val);
                    message[val]->timeToRun = 2000000; //one millisecond RUNTIME EACH ITERATION
                    message[val]->running=1;
                    msgsnd(msqid, message[val], MSG, 0);
                    int dispatch = rand()%10000+100;
                    shm_ptr->systemTime.nanoseconds += dispatch;
                    writeLogRunProcess(logfile, val, 1, shm_ptr->systemTime.seconds, shm_ptr->systemTime.nanoseconds, dispatch);
                    msgrcv(msqid, message[val+20], MSG, val+21,0);
                    if(shm_ptr->processBlock[val].timeLeft< 0 || message[val+20]->running==0)
                    {
                        if(shm_ptr->processBlock[val].timeLeft< 0)
                        {
                            shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=shm_ptr->processBlock[val].timeLeft;
                        }
                        else //process wants to terminate itself
                        {
                            shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=message[val+20]->timeToRun;
                        }
                        printf("%d Ran out of time\n", val);
                        message[val]->running=0;
                        if(message[val+20]->running==1)
                        {
                            msgsnd(msqid, message[val], MSG, 0);
                            msgrcv(msqid, message[val+20], MSG, val+21, 0);
                        }
                        processOpen[val]=0;
                        writeLogEnd(logfile, val, shm_ptr->processBlock[val].timeInSystem.seconds,shm_ptr->processBlock[val].timeInSystem.nanoseconds);
                    }
                    else //ran normally
                    {
                        if(message[val+20]->running==2) //IT DECIDED TO BLOCK
                        {
                            enqueue(&BlockQueue,val);
                            writeLogQueue(logfile, val, 4);
                        }
                        else //IT RAN NORMALLY
                        {
                            enqueue(&priority2,val);
                            writeLogQueue(logfile, val, 2);
                        }
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft -= message[val+20]->timeToRun;
                        newProcessTimer-=message[val+20]->timeToRun;
                        printf("%d has %d time left\n", val, shm_ptr->processBlock[val].timeLeft);
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                    }
                    if(newProcessTimer<0) break;

                    val = dequeue(&BlockQueue);
                    if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                    {
                        enqueue(&BlockQueue, val);
                        val = dequeue(&priority1);
                    }
                    else if(val==-1) val = dequeue(&priority1);
                    else writeLogUnblock(logfile, val);


                }

                if(newProcessTimer<0) break;
///////////////////////////////////////////////////////////////////////////////////////////////////// QUEUE 2 START

                val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                {
                    enqueue(&BlockQueue, val);
                    val = dequeue(&priority2);
                }
                else if(val==-1) val = dequeue(&priority2);
                else writeLogUnblock(logfile, val);

                while(val>-1)
                {
                    pran=1;
                    fflush(stdout);
                    printf("DEQUEUE: %d\n", val);
                    message[val]->timeToRun = 4000000; //one millisecond
                    message[val]->running=1;
                    msgsnd(msqid, message[val], MSG, 0);
                    int dispatch = rand()%10000+100;
                    shm_ptr->systemTime.nanoseconds += dispatch;
                    writeLogRunProcess(logfile, val, 2, shm_ptr->systemTime.seconds, shm_ptr->systemTime.nanoseconds, dispatch);
                    msgrcv(msqid, message[val+20], MSG, val+21,0);
                    if(shm_ptr->processBlock[val].timeLeft < 0 || message[val+20]->running==0)
                    {
                        if(shm_ptr->processBlock[val].timeLeft< 0)
                        {
                            shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=shm_ptr->processBlock[val].timeLeft;
                        }
                        else
                        {
                            shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=message[val+20]->timeToRun;
                        }

                        printf("%d Ran out of time\n", val);
                        message[val]->running=0;
                        if(message[val+20]->running==1)
                        {
                            msgsnd(msqid, message[val], MSG, 0);
                            msgrcv(msqid, message[val+20], MSG, val+21, 0);
                        }
                        processOpen[val]=0;
                        writeLogEnd(logfile, val, shm_ptr->processBlock[val].timeInSystem.seconds,shm_ptr->processBlock[val].timeInSystem.nanoseconds);
                    }
                    else
                    {
                        if(message[val+20]->running==2)
                        {
                            enqueue(&BlockQueue,val);
                            writeLogQueue(logfile, val, 4);
                        }
                        else
                        {
                            enqueue(&priority3,val);
                            writeLogQueue(logfile, val, 3);
                        }
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft -= message[val+20]->timeToRun;
                        newProcessTimer-=message[val+20]->timeToRun;
                        printf("%d has %d time left\n", val, shm_ptr->processBlock[val].timeLeft);
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                    }
                    if(newProcessTimer<0) break;

                    val = dequeue(&BlockQueue);
                    if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                    {
                        enqueue(&BlockQueue, val);
                        val = dequeue(&priority2);
                    }
                    else if(val==-1) val = dequeue(&priority2);
                    else writeLogUnblock(logfile, val);

                }
                if(newProcessTimer<0) break;
///////////////////////////////////////////////////////////////////////////////////////////////////// QUEUE 3 START

                val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                {
                    enqueue(&BlockQueue, val);
                    val = dequeue(&priority3);
                }
                else if(val==-1) val = dequeue(&priority3);
                else writeLogUnblock(logfile, val);

                while(val>-1)
                {
                    pran=1;
                    fflush(stdout);
                    printf("DEQUEUE: %d\n", val);
                    message[val]->timeToRun = 8000000; //one millisecond
                    message[val]->running=1;
                    msgsnd(msqid, message[val], MSG, 0);
                    int dispatch = rand()%10000+100;
                    shm_ptr->systemTime.nanoseconds += dispatch;
                    writeLogRunProcess(logfile, val, 3, shm_ptr->systemTime.seconds, shm_ptr->systemTime.nanoseconds, dispatch);
                    msgrcv(msqid, message[val+20], MSG, val+21,0);
                    if(shm_ptr->processBlock[val].timeLeft< 0 || message[val+20]->running==0)
                    {
                        if(shm_ptr->processBlock[val].timeLeft< 0)
                        {
                            shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=shm_ptr->processBlock[val].timeLeft;
                        }
                        else
                        {
                            shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                            shm_ptr->processBlock[val].timeLeft = 0;
                            newProcessTimer-=message[val+20]->timeToRun;
                        }

                        printf("%d Ran out of time\n", val);
                        message[val]->running=0;
                        if(message[val+20]->running==1)
                        {

                            msgsnd(msqid, message[val], MSG, 0);
                            msgrcv(msqid, message[val+20], MSG, val+21, 0);
                        }
                        processOpen[val]=0;
                        writeLogEnd(logfile, val, shm_ptr->processBlock[val].timeInSystem.seconds,shm_ptr->processBlock[val].timeInSystem.nanoseconds);
                    }
                    else
                    {
                        if(message[val+20]->running==2)
                        {
                            enqueue(&BlockQueue, val);
                            writeLogQueue(logfile, val, 4);
                        }
                        else
                        {
                            enqueue(&priority3,val);
                            writeLogQueue(logfile, val, 3);
                        }
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft -= message[val+20]->timeToRun;
                        newProcessTimer-=message[val+20]->timeToRun;
                        printf("%d has %d time left\n", val, shm_ptr->processBlock[val].timeLeft);
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                    }
                    if(newProcessTimer<0) break;

                    val = dequeue(&BlockQueue);
                    if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds)
                    {
                        enqueue(&BlockQueue, val);
                        val = dequeue(&priority3);
                    }
                    else if(val==-1) val = dequeue(&priority3);
                    else writeLogUnblock(logfile, val);

                }
                processRan=pran;
                if(newProcessTimer<0) break;
                processRan=pran;
            }///////////////////////////////////////////////////////////////////////////////////////////////////// END MAIN DRIVER

            if(childpid==0) break;

            int id = waitpid(-1, NULL, WNOHANG);
            if(id != 0)
            {
                for(int j=0; j<20; j++)
                {                                                           //WAIT FOR ANY CHILDREN
                    if(id==pidArray[j]) processOpen[j] = 0;
                }
                count--;
            }


        }
//SLAVE PROCESS CODE
        if(childpid==0)
        {
            fprintf(stderr, "SLAVE:I:%d PID:%d PPID:%d CID:%d\n",i, getpid(),getppid(),childpid);
            char indchar[10];
            sprintf(indchar, "%d", kval); //TO SEND CHILD ITS PID NUMBER
            char nchar[10];
            int p=100;
            sprintf(nchar, "%d", p);
            char *s[] = { "./user", indchar, (char *)shm_ptr,filename, NULL}; //SET UP EXEC
            printf("EXECUTING SLAVE\n");
            execvp(s[0], s);
        }


		unsigned long int avgwait;
                unsigned long int avgblock;
                unsigned long int avgrun;


//WAIT FOR ANY REMAINING PROCESSES
        while(1)
        {
            childpid=wait(NULL);
            printf("waited for %d, Press Ctrl-C to End\n", childpid);
		for(int l=0; l<100000; l++){
		avgwait+=shm_ptr->waittime[l];
		if(shm_ptr->waittime[l]==0){
		avgwait=(avgwait/l); break;
		}
		}
for(int l=0; l<100000; l++){
                avgblock+=shm_ptr->blocktime[l];
                if(shm_ptr->blocktime[l]==0){
                avgblock=(avgblock/l); break;
                }
                }
for(int l=0; l<100000; l++){
                avgrun+=shm_ptr->runtime[l];
                if(shm_ptr->runtime[l]==0){
                avgrun=(avgrun/l); break;
                }
                }

		printf("AVG RUN:%ld ns\n AVG IDLE:%ld ns\n AVG BLK: %ld ns\n", avgrun, avgwait, avgblock);
		logfile=fopen("AVERAGESTATS.txt","w");
        fprintf(logfile, "AVG RUN:%ld ns\n AVG IDLE:%ld ns\n AVG BLK: %ld ns\n", avgrun, avgwait, avgblock);
        fclose(logfile);  

            if(childpid==-1) break;
        }


	logfile=fopen("AVERAGESTATS.txt","w");
	fprintf(logfile, "AVG RUN:%ld ns\n AVG IDLE:%ld ns\n AVG BLK: %ld ns\n", avgrun, avgwait, avgblock);
	fclose(logfile);

//FREE UP MEMORY
        msgctl(msqid, IPC_RMID, NULL);		//FREE SHARED MESSAGE QUEUE
        shmctl(shm_id, IPC_RMID, NULL);		//FREE SHARED MEMORY DATA

//DONE
        printf("SIMULATION COMPLETE\n");
        return 0;
    }

}

@


1.3
log
@update
@
text
@d31 5
a35 6
	    
  while(1)
        {
            int childpid=wait(NULL);
            if(childpid==-1) break;
        }
d37 1
a37 1
if(pid!=getpid())
d40 2
a41 2
   msgctl(msqid, IPC_RMID, NULL);          //FREE SHARED MESSAGE QUEUE
        shmctl(shm_id, IPC_RMID, NULL);         //FREE SHARED MEMORY DATA
d44 1
d46 10
d58 8
a65 1
void HANDLER(int sig){
d67 7
d75 8
a82 5
  while(1)
        {
            int childpid=wait(NULL);
            if(childpid==-1) break;
        }
d84 6
a89 6
   msgctl(msqid, IPC_RMID, NULL);          //FREE SHARED MESSAGE QUEUE
        shmctl(shm_id, IPC_RMID, NULL);         //FREE SHARED MEMORY DATA



exit(0);
d91 5
d97 2
a98 2

/////////////////////////////////////////////////////MAIN//////////
a114 1
        char filename[20];
d159 5
d175 1
a175 1
	node_t *BlockQueue= NULL;
d210 6
a215 1

d246 1
d250 1
a250 1
      	//INITIALIZE DATA FOR LOOP CONTROL
d252 3
a254 3
        int k=0;
	int newProcessTimer;
         while(run==0 && i < 100)
d256 1
a256 1
		 newProcessTimer = rand()%maxTimeBetweenNewProcs+1;
d263 1
a263 1
                    if(id==pidArray[j]) processOpen[j] = 0;
d265 1
a265 1
		count--;
d267 2
a268 2
            
            	//INCREMENT LOOP CONTROL
d270 11
a280 3
            if(i==100) return 0;
		for(; k<21; k++)
            {	fflush(stdout);
d282 2
a283 2
                if(k==20) k=0;
                if(processOpen[k]==0) 		//Check bit array
d286 1
a286 1
                    processOpen[k]=1;
d289 2
a290 1
                    int randprior = rand()%100 + 1;
d293 1
d296 1
d302 1
d305 1
d311 1
a311 1
                    int runtime = rand()%(maxTimeBetweenNewProcs) +1;
d313 3
a315 1
		    shm_ptr->processBlock[k].timeUsedLast=0;
d318 4
a321 2
		    i++;
		    childpid = fork();		//CREATE CHILD
d324 1
a325 2
            }	
		
d327 1
a327 1
	                if(childpid==0) break;
d329 1
d335 15
a349 9
		int processRan=1;
        
	    while(count<21 && childpid>0 && processRan==1)
            {	processRan =0;
		if(shm_ptr->systemTime.nanoseconds>1000000000){
		shm_ptr->systemTime.seconds++;
		shm_ptr->systemTime.nanoseconds-=1000000000;
		}
		int pran=0;
d352 4
a355 3
                {   
		    print_list(priority0);
		    pran=1; fflush(stdout);
d359 4
a362 2
		    msgsnd(msqid, message[val], MSG, 0);
shm_ptr->systemTime.nanoseconds += rand()%10000+100;
d364 2
a365 2
                    if(shm_ptr->processBlock[val].timeLeft < 0 || message[val+20]->running==0)
		    {
d370 1
a370 1
			newProcessTimer-=shm_ptr->processBlock[val].timeLeft;
d372 10
a381 6
			message[val]->running=0;
			if(message[val+20]->running==1){
			msgsnd(msqid, message[val], MSG, 0);
			msgrcv(msqid, message[val+20], MSG, val+21, 0);}
			processOpen[val]=0;
                   } else
d383 4
a386 2
                        enqueue(&priority0,val);
			newProcessTimer-=message[val+20]->timeToRun;
d393 1
a393 1
			if(newProcessTimer<0) break; 
d397 12
a408 2
		processRan=pran;
		if(newProcessTimer<0) break;
d410 4
a413 8
		val = dequeue(&BlockQueue);
		if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
		enqueue(&BlockQueue, val);
		val = dequeue(&priority1);}

		while(val>-1)
                {   
		    pran=1; fflush(stdout);
d415 1
a415 1
                    message[val]->timeToRun = 2000000; //one millisecond
d418 3
a420 1
		    shm_ptr->systemTime.nanoseconds += rand()%10000+100;
d423 17
a439 13
                    {   if(shm_ptr->processBlock[val].timeLeft< 0){
                        shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeLeft = 0;
			newProcessTimer-=shm_ptr->processBlock[val].timeLeft;}
			else{
			shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun; 
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=message[val+20]->timeToRun;
			}
d442 5
a446 3
			                        if(message[val+20]->running==1){
                        msgsnd(msqid, message[val], MSG, 0);
			msgrcv(msqid, message[val+20], MSG, val+21, 0);}
d448 14
a461 3
                    }else{
			 if(message[val+20]->running==2)enqueue(&BlockQueue,val);
			else enqueue(&priority2,val);
d464 1
a464 1
			newProcessTimer-=message[val+20]->timeToRun;
d469 10
a478 1
			if(newProcessTimer<0) break;
a479 4
                     val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
                enqueue(&BlockQueue, val);
                val = dequeue(&priority1);}
d483 2
a484 1
		if(newProcessTimer<0) break;
d486 8
a493 4
		 val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
                enqueue(&BlockQueue, val);
                val = dequeue(&priority2);}
d495 4
a498 2
		while(val>-1)
                {   pran=1; fflush(stdout);
d503 3
a505 1
                    shm_ptr->systemTime.nanoseconds += rand()%10000+100;
d509 15
a523 12
if(shm_ptr->processBlock[val].timeLeft< 0){
                        shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=shm_ptr->processBlock[val].timeLeft;}
                        else{
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=message[val+20]->timeToRun;
d525 2
a526 2
                        
printf("%d Ran out of time\n", val);
d528 5
a532 3
			                        if(message[val+20]->running==1){
                        msgsnd(msqid, message[val], MSG, 0);
			msgrcv(msqid, message[val+20], MSG, val+21, 0);}
d534 14
a547 3
  		}else{
                         if(message[val+20]->running==2)enqueue(&BlockQueue,val);
                        else enqueue(&priority2,val);
d550 1
a550 1
			newProcessTimer-=message[val+20]->timeToRun;
d555 1
a555 1
			if(newProcessTimer<0) break;
d557 8
a564 11
                     val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
                enqueue(&BlockQueue, val);
                val = dequeue(&priority2);}
		
                }
		if(newProcessTimer<0) break;
		 val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
                enqueue(&BlockQueue, val);
                val = dequeue(&priority3);}
d566 17
a582 2
		while(val>-1)
                {   pran=1; fflush(stdout);
d587 3
a589 1
                    shm_ptr->systemTime.nanoseconds += rand()%10000+100;
d593 15
a607 12
if(shm_ptr->processBlock[val].timeLeft< 0){
                        shm_ptr->systemTime.nanoseconds += shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeUsedLast = shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=shm_ptr->processBlock[val].timeLeft;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=shm_ptr->processBlock[val].timeLeft;}
                        else{
                        shm_ptr->systemTime.nanoseconds += message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeUsedLast = message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeInSystem.nanoseconds+=message[val+20]->timeToRun;
                        shm_ptr->processBlock[val].timeLeft = 0;
                        newProcessTimer-=message[val+20]->timeToRun;
d609 2
a610 2
                        
printf("%d Ran out of time\n", val);
d612 2
a613 1
			                        if(message[val+20]->running==1){
d615 18
a632 6
                        msgsnd(msqid, message[val], MSG, 0);
			msgrcv(msqid, message[val+20], MSG, val+21, 0);}
			processOpen[val]=0;
			  }else{
                         if(message[val+20]->running==2)enqueue(&BlockQueue, val);
                        else enqueue(&priority2,val);
d635 1
a635 1
			newProcessTimer-=message[val+20]->timeToRun;
d640 10
a649 1
			if(newProcessTimer<0) break;
d651 5
a655 9
                     val = dequeue(&BlockQueue);
                if(val>-1 && shm_ptr->processBlock[val].UnblockTime>shm_ptr->systemTime.nanoseconds){
                enqueue(&BlockQueue, val);
                val = dequeue(&priority3);}

                }processRan=pran;
		if(newProcessTimer<0) break;
		processRan=pran;
            }
d663 1
a663 1
                {
d676 1
a676 1
            sprintf(indchar, "%d", k);
d686 4
d695 25
a719 1
            printf("waited for %d\n", childpid);
d723 4
@


1.2
log
@OLD STUFF imported
@
text
@d1 542
a542 227
//MASTER PROGRAM
#define _GNU_SOURCE
#define _SVID_SOURCE
#define _POSIX_SOURCE
#include <string.h>
#include <errno.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/msg.h>

//GLOBALS
int pid;
int run;


//KILL CHILDREN
void kill_child(int sig){
printf("killing all\n");
if(pid!=getpid())
kill(getpid(),SIGINT);
run=1;
}

//DATA STRUCT FOR MEMORY SHARING
struct data{
int seconds;
int nanoseconds;
};

//DATA STRUCT FOR MESSAGE QUEUE
#define MAXSIZE 4096
typedef struct {   
long mtype;   
char mtext[MAXSIZE];
 } mymsg_t;


/////////////////////////////////////////////////////MAIN//////////
int main(int argc, char *argv[]){
//SET GLOBALS
run=0;
pid=getpid();

//SET UP SIGNAL HANDLING
signal(SIGALRM,(void (*)(int))kill_child);
while(run==0){

//INITIALIZE VARS
char opt;
int s;
int z;
char filename[20];
pid_t childpid;

//GET OPTION IS SET
while ( (opt= getopt(argc,argv, "dhs:l:t:")) !=-1 ){
            switch ( opt) {
                case 'h': printf("-s [slave#]\n -l [logfile]\n -t [time]\n -d FOR DEFAULTS"); 
			return 0;
		case 'l': memcpy(filename, optarg, 20);
		break;
		case 's': s = atoi(optarg);
		break;
                case 't': z = atoi(optarg);
		break;
		case 'd': 
			s = 5; 
			z=20; 
                	memcpy(filename, "file.log", 10);
		break;
            }
}

//CHECK FOR VALID NUMBER OF COMMAND ARGS & VALID N
if (argc == 1 ){
        fprintf(stderr, "See ./oss -h for help\n");
        return 1;
   }

//SET AN ALARM IF PROGRAM TAKES TOO LONG
alarm(z);

//SHOW USER WHAT ARGS WE RECEIVED
printf("Running with S:%d T:%d L:%s\n", s, z, filename);

//INITIALIZE DATA VARS
int       shm_id;
key_t     mem_key;
struct data    *shm_ptr;

//GENERATE KEY
mem_key = ftok("a", 1);
shm_id = shmget(mem_key, sizeof(struct data), IPC_CREAT | 
0666);
if (shm_id < 0) {
     perror("shmget");
     exit(1);
}

//ATTACH OR CREATE DATA STRUCT
shm_ptr = (struct data *) shmat(shm_id, NULL, 0);  /* attach */
if ((long) shm_ptr == -1) {
     perror("shmat");
     exit(1);
}

//Initialize DATA
shm_ptr->seconds=0;
shm_ptr->nanoseconds=0;

//DATA STRUCT SUCCESS
printf("data struct made\n");

//INITIALIZE MESSAGE QUEUE
key_t key; /* key to be passed to msgget() */ 
//int msgflg; /* msgflg to be passed to msgget() */ 
int msqid; /* return value from msgget() */ 
mymsg_t *message;					//MESSAGE FOR CRITCAL SECTIONS
message = ( mymsg_t *) malloc(MAXSIZE + sizeof(long));
mymsg_t *message2;					//MESSAGE FOR LOGFILE
message2 = ( mymsg_t *) malloc(MAXSIZE + sizeof(long));
key=ftok("/b",1);					//GENERATE KEY
msqid = msgget(key, (IPC_CREAT | 0666));
msgctl(msqid, IPC_RMID, NULL);
msqid = msgget(key, (IPC_CREAT | 0666));		//IF MSQID EXISTS, REMOVE IT AND WRITE OVER
memcpy(message->mtext, "", 100);
memcpy(message2->mtext, "", 100);			//INITIALIZE MESSAGE TEXTS
message->mtype=1;
message2->mtype=2;					//INITIALIZE MESSAGE TYPES
printf("trying to send message\n");
msgsnd(msqid, message, MAXSIZE, 0);			//INITIALIZE FIRST MESSAGE FOR CRITICAL SECTION

for(int j=0; j<s; j++){
msgsnd(msqid, message2, 400, 0);
}

//MESSAGE SET UP SUCCESS
printf("message queue 1 made\n");

//CREATE OR OVERWRITE A LOGFILE
FILE * logfile;
logfile=fopen(filename,"w");
fclose(logfile);


//MAKE CHILDREN
printf("creating children\n");
int limit=s;
int i=-1;	//INITIALIZE DATA FOR LOOP CONTROL
int count=0;

while(run==0 && i < 100){
if(count==limit){	//ONLY ALLOW MAX LIMIT OF PROCESSES AT A TIME
wait(NULL);	//WAIT WHILE AT MAX LIMIT
count--;
}
count++;
i++;	//INCREMENT LOOP CONTROL

if(i==100) return 0;
childpid = fork();		//CREATE CHILD

if(childpid<0){
perror("childpid");	//HANDLE FORK ERROR
exit(1);
}

if(childpid==0){
msgrcv(msqid, message2, 400, 2, 0); //RECEIVE MESSAGE FROM DYING CHILD
shm_ptr->nanoseconds+=100;			//INCREMENT CLOCK BY 100ns FOR SIMULATED CONTEXT SWITCH
logfile=fopen(filename, "a");
fprintf(logfile, message2->mtext);		//WRITE DATA FROM MESSAGE2 TO LOGFILE
fprintf(logfile, "Creating child I:%d PID:%d at my time %ds %dns\n",i, getpid(), shm_ptr->seconds, shm_ptr->nanoseconds);
fclose(logfile);
msgsnd(msqid, message, MAXSIZE, 0);		//SEND MESSAGE TO ALLOW CRITICAL SECTIONS TO CONTINUE
break;
}

if(waitpid(-1, NULL, WNOHANG) != 0)
{
count--;
}
}

//SLAVE PROCESS CODE
if(childpid==0){
fprintf(stderr, "SLAVE:I:%d PID:%d PPID:%d CID:%d\n",i, getpid(),getppid(),childpid);
char indchar[10];
sprintf(indchar, "%d", i);
char nchar[10];
int p=100;
sprintf(nchar, "%d", p);
char *s[] = { "./user", indchar, (char *)shm_ptr,filename, NULL}; //SET UP EXEC
printf("EXECUTING SLAVE\n");
execvp(s[0], s);
}



//WAIT FOR ANY REMAINING PROCESSES
while(1){
childpid=wait(NULL);
printf("waited for %d\n", childpid);
if(childpid==-1) break;
}


//FREE UP MEMORY				
msgctl(msqid, IPC_RMID, NULL);		//FREE SHARED MESSAGE QUEUE
shmctl(shm_id, IPC_RMID, NULL);		//FREE SHARED MEMORY DATA
free(message);
free(message2);				//FREE MESSAGE STRUCT DATA

//DONE
printf("SIMULATION COMPLETE\n");
return 0;
}

}

@


1.1
log
@Initial revision
@
text
@d1 226
a226 1
//MASTER PROCESS
@
